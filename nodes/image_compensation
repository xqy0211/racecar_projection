#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import numpy as np
import cv2
from cv_bridge import CvBridge
from sensor_msgs.msg import Image, CompressedImage
from dynamic_reconfigure.server import Server
from racecar_projection.cfg import ImageCompensationParamsConfig

class ImageCompensation():
    def __init__(self):
        self.clip_hist_percent = rospy.get_param("/camera/extrinsic_camera_calibration/clip_hist_percent", 1.)

        self.is_calibration_mode = rospy.get_param("~is_extrinsic_camera_calibration_mode", False)
        if self.is_calibration_mode == True:
            srv_image_compensation = Server(ImageCompensationParamsConfig, self.cbGetImageCompensationParam)

        self.sub_image_type = "compressed"  # "compressed" / "raw"
        self.pub_image_type = "raw"         # "compressed" / "raw"

        if self.sub_image_type == "compressed":
            # subscribes compressed image 
            self.sub_image_original = rospy.Subscriber('/camera/image_input/compressed', CompressedImage, self.cbImageCompensation, queue_size = 1)
        elif self.sub_image_type == "raw":
            # subscribes raw image 
            self.sub_image_original = rospy.Subscriber('/camera/image_input', Image, self.cbImageCompensation, queue_size = 1)

        if self.pub_image_type == "compressed":
            # publishes compensated image in compressed type 
            self.pub_image_compensated = rospy.Publisher('/camera/image_output/compressed', CompressedImage, queue_size = 1)
        elif self.pub_image_type == "raw":
            # publishes compensated image in raw type
            self.pub_image_compensated = rospy.Publisher('/camera/image_output', Image, queue_size = 1)

        self.cvBridge = CvBridge()

    def cbGetImageCompensationParam(self, config, level):
        rospy.loginfo("[Image Compensation] Extrinsic Camera Calibration Parameter reconfigured to")
        rospy.loginfo("clip_hist_percent : %f", config.clip_hist_percent)

        self.clip_hist_percent = config.clip_hist_percent

        return config

    def cbImageCompensation(self, msg_img):
        if self.sub_image_type == "compressed":
            # converts compressed image to opencv image
            np_image_original = np.fromstring(msg_img.data, np.uint8)
            cv_image_original = cv2.imdecode(np_image_original, cv2.IMREAD_COLOR)
        elif self.sub_image_type == "raw":
            # converts raw image to opencv image
            cv_image_original = self.cvBridge.imgmsg_to_cv2(msg_img, "bgr8")

        cv_image_compensated = np.copy(cv_image_original)

        ## Image compensation based on pseudo histogram equalization 伪直方图均衡化
        clip_hist_percent = self.clip_hist_percent
        
        hist_size = 256
        min_gray = 0
        max_gray = 0
        alpha = 0
        beta = 0

        #转化为灰度图像
        gray = cv2.cvtColor(cv_image_compensated, cv2.COLOR_BGR2GRAY)

        # histogram calculation
        if clip_hist_percent == 0.0:
            #计算最大值最小值，后两个返回值为索引，此处不需
            min_gray, max_gray, _, _ = cv2.minMaxLoc(gray)
        else:
            #计算直方图：[处理的图像]，使用的通道0（因为使用灰度图）,不使用掩膜，直方图分为多少份（多少个直方柱），直方图能表示像素值从0到hist_size的像素
            hist = cv2.calcHist([gray], [0], None, [hist_size], [0, hist_size])

            #hist按照行累加
            accumulator = np.cumsum(hist)
            
            max = accumulator[hist_size - 1]

            clip_hist_percent *= (max / 100.)
            clip_hist_percent /= 2.

            min_gray = 0
            while accumulator[min_gray] < clip_hist_percent:
                min_gray += 1
            
            max_gray = hist_size - 1
            while accumulator[max_gray] >= (max - clip_hist_percent):
                max_gray -= 1

        input_range = max_gray - min_gray

        alpha = (hist_size - 1) / input_range
        beta = -min_gray * alpha

        #实现图像增强等相关操作的快速运算,将其转回原来的uint8形式
        cv_image_compensated = cv2.convertScaleAbs(cv_image_compensated, -1, alpha, beta)

        if self.pub_image_type == "compressed":
            # publishes compensated image in compressed type
            self.pub_image_compensated.publish(self.cvBridge.cv2_to_compressed_imgmsg(cv_image_compensated, "jpg"))

        elif self.pub_image_type == "raw":
            # publishes compensated image in raw type
            self.pub_image_compensated.publish(self.cvBridge.cv2_to_imgmsg(cv_image_compensated, "bgr8"))

    def main(self):
        rospy.spin()

if __name__ == '__main__':
    rospy.init_node('image_compensation')
    node = ImageCompensation()
    node.main()
